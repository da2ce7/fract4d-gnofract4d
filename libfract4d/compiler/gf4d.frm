comment {

This file contains the standard fractal types shipped with Gnofract4D.

If you modify these formulas, import of .fct files generated by previous
Gnofract4D versions may not work, so I suggest copying the formulas to
another file and renaming them before changing them.
 
In some cases, these have been adapted from Fractint formulas. 
These have had -G4 appended to avoid any confusion.
}

Mandelbrot {
init:
	; nothing to do here
loop:
	z = z * z + #pixel
bailout:
	|z| <= 4
}

Mandelbar {
init:
	; nothing to do here
loop:
	z = conj(z)^@p1 + #pixel
bailout:
	|z| <= 4
}

Quadratic {
init:
	; nothing to do here
loop:
	z = (@p1 * z + @p2) * z + @p3 * #pixel
bailout:
	|z| <= 4
}

Cubic Mandelbrot {
init:
	; nothing to do here
loop:
	z = z * z * (z - 3.0 * @p1) + #pixel
bailout:
	|z| <= 4
}

ManZPower {
loop:
	z = z^@p1 + #pixel
bailout:
	|z| <= 4
}

Barnsley Type 1 {
loop:
	float x_cy = real(z) * imag(#pixel)
	float x_cx = real(z) * real(#pixel)
	float y_cy = imag(z) * imag(#pixel)
	float y_cx = imag(z) * real(#pixel)

	if(real(z) >= 0)
		z = (x_cx - real(#pixel) - y_cy, y_cx - imag(#pixel) + x_cy)
	else 
		z = (x_cx + real(#pixel) - y_cy, y_cx + imag(#pixel) + x_cy)
	endif
bailout:
	|z| <= 4
}

Barnsley Type 2 {
loop:
	float x_cy = real(z) * imag(#pixel)
	float x_cx = real(z) * real(#pixel)
	float y_cy = imag(z) * imag(#pixel)
	float y_cx = imag(z) * real(#pixel)

	if(real(z) * imag(#pixel) + imag(z) * real(#pixel) >= 0)
		z = (x_cx - real(#pixel) - y_cy, y_cx - imag(#pixel) + x_cy)
	else 
		z = (x_cx + real(#pixel) - y_cy, y_cx + imag(#pixel) + x_cy)
	endif
bailout:
	|z| < 4
}

Barnsley Type 3 {
loop:
	float x2 = real(z) * real(z)
	float y2 = imag(z) * imag(z)
	float xy = real(z) * imag(z)

	if(real(z) > 0)
		z = (x2 - y2 - 1.0, xy * 2.0)
	else
		z = (x2 - y2 - 1.0 + real(#pixel) * real(z), \
		     xy * 2.0 + imag(#pixel) * real(z))
	endif
bailout:
	|z| < 4.0
}

Buffalo {
loop:
	z = (abs(real(z)),abs(imag(z)))
	z = (z - 1.0) * z + #pixel
bailout:
	|z| < 4.0
}     
		
Burning Ship {
loop:
	z = (abs(real(z)),abs(imag(z)))
	z = z*z + #pixel
bailout: 
	|z| < 4.0
}

Cubic Burning Ship {
loop:
	z = (abs(real(z)),abs(imag(z)))
	z = z*z*z + #pixel
bailout: 
	|z| < 4.0
}

Lambda {
loop:
	t = z * (1.0 - z)
	z = t * #pixel
bailout:
	|z| < 4.0
}

Magnet {
loop:
	z = (z * z + #pixel - 1.0)/(2.0 * z + #pixel - 2.0)
	z = z *z
bailout:
	|z| < 4.0
}

Magnet 2 {
loop:
	cm1 = #pixel - 1.0, cm2 = #pixel - 2.0
	z = (z * z * z + 3.0 * cm1 * z + cm1 * cm2)/ \
	     (3.0 * z * z + 3.0 * cm2 * cm2 + cm1 * cm2 + 1.0)
	z = z*z

bailout:
	|z| < 4.0
}

Newton {
init:
	nm1 = @p1 - 1.0
loop:
	last = z
	;z = z - (pow(z,@p1) - 1.0)/ (@p1 * pow(z,nm1))
	z = z - (z*z*z - 1.0)/(3.0 * z * z)
bailout:
	|z - last| > 1.0e-9
}

Nova {
loop:
	last = z
	z = z - (@p1 * z * z * z - @p2)/(@p3 * z * z) + #pixel
bailout:
	|z - last| > 1.0e-9
}


Tetrate {
loop:
	z = #pixel^z
bailout:
	|z| < 4.0
}


T02-01-G4 {; Modified for Gf4d by EY
	; V.1.1 - earlier versions may be discarded
        ; Copyright (c)1998,1999 Morgan L. Owens
        ; Chebyshev Types:
        ; Inspired by Clifford A. Pickover:
        ; Dynamic (Euler method)
        ;
        ; T(n+1) = 2xT(n)-T(n-1)
        ; T(0)  = 1
        ; T(1)  = x
        ;
        ; = 2zT01-T00
  t=z, bailout=4, z=pixel:
  x=real(z), y=imag(z)
  Tx=(x+x)*x-1
  Ty=(y+y)*y-1
  x=x-t*Ty, y=y+t*Tx
  z=x+flip(y)
  |z|<=bailout
}

T03-01-G4 {; based on T03-01 in CHBY1.FRM by Morgan L. Owens
        ; Modified for Gf4D by EY
        ; = 2zT02-T01
  t=z, bailout=4, z=pixel:
  float x=real(z), float y=imag(z)
  float Tx=x*(4*x*x-3)
  float Ty=y*(4*y*y-3)
  cx=x-t*Ty, cy=y+t*Tx
  z=cx+flip(cy)
  |z|<=bailout
}
