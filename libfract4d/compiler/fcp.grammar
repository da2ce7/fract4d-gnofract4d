# grammar file - needs Rockit to compile


Grammar Fractal
Tokens
  Comment    = /;[^\r\n]*/                            [:Skip]
  Blank      = /(( )|(\t)|(\v))+/                     [:Skip]
  Identifier = /[#@]?[A-Z]([A-Z]|\d)*/i
  Float      = /(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?/ # Perl Cookbook p.44
  #Integer    = /\d+/
  String     = /"[^\r\n]*"/
  Newline    = /(\r\n)|(\r)|(\n)/
  FormulaID  = /[-A-Z0-9_]+/i
  Type       = /(bool)|(int)|(float)|(complex)|(color)/i

Productions
   Formulas -> Formula+              [Formulas: formulas]
   Formula -> FormulaName '{' Newline FormulaBody '}' [Formula: name, _, _, body, _]
           | Newline

   FormulaName -> FormulaID                [FormID: name]
              | FormulaID '(' Identifier ')'    [FormID: name,_,id]

   FormulaBody -> Section+ [FormulaBody: sections]

   Section -> 'init' ':' Newline Statements [Section: name, _, _, statements]
           |  'loop' ':' Newline Statements [Section: name, _, _, statements]
           |  'bailout' ':' Newline CondExp Newline  [Section: name, _, _, exp]
           |  'default' ':' Newline Defstatements [Section: name, _, _, statements]
           # global, transform, builtin, switch, final

   Defstatements -> Defstatement+    [Defstatements: defstatements]
   Defstatement -> Setting [^]
              | "param" Identifier Newline 
                   Settings
              | "endparam" Newline [Param: _,id,_,settings,_,_]

   Settings -> Setting+ [Settings: settings]
   Setting -> Identifier '=' Value Newline [Setting: id,_,value,_]

   Value -> String [^]
         |  Exp [^]

   Statements -> Statement+          [Statements: statements]
   Statement -> AssignExp            [^] 
              | Type AssignExp       [TypedAssignment: type, exp]

   AssignExp -> Identifier '=' Exp Newline [Assignment: id,_,exp,_]
             #|  Type Identifier Newline [Declaration: type, id, _]
 
   CondExp -> Exp ('<' | '>' | '==' | '<=' | '>=' | '!=' ) Exp     
                                     [Condition: left, op, right]

   Exp       -> Number              [^]
	     |  Identifier          [^]
	     |  '(' Exp ')'        [^: _,expr,_]
             |  '|' Exp '|'        [UnExp: op, exp, _]
             |  '-' Exp            [NegExp: op, exp]
             |  Exp ('+'|'-') Exp  [AddExp: left,op,right]
             |  Exp ('*'|'/'|'%') Exp [MulExp: left,op,right]
             |  Exp '^' Exp      [PowExp: left,op,right]
             #| '(' Number ',' Number ')'  [Complex: left,_,right]

  Number -> #Integer [^]
           Float   [^]
 
#         | Integer 'i' [Complex: left,_] # FIXME
 

Priorities
        left(PowExp), left(MulExp), left(AddExp) left(Condition)
        #right(AssignExp)
        PowExp = NegExp > MulExp > AddExp > Condition > Assignment
