# grammar file - needs Rockit to compile


Grammar Fractal
Tokens
  Comment    = /;[^\r\n]*/                            [:Skip]
  Blank      = /(( )|(\t)|(\v))+/                     [:Skip]
  Identifier = /[#@]?[A-Z]([A-Z]|\d)*/i
  Float      = /(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?/ # Perl Cookbook p.44
  #Integer    = /\d+/
  String     = /"[^\r\n]*"/
  Newline    = /(\r\n)|(\r)|(\n)/
  FormulaID  = /[-A-Z0-9_]+/i
  Type       = /(bool)|(int)|(float)|(complex)|(color)/i

Productions
    Formulas -> Formula+              [Formulas: formulas]
    Formula -> FormulaName '{' Newline FormulaBody '}' Newline* [Formula: name, _, _, body, _, _]
            

    FormulaName -> FormulaID                [FormID: name]
               | FormulaID '(' Identifier ')'    [FormID: name,_,id]

    FormulaBody -> Section+ [FormulaBody: sections]

    Section -> 'init' ':' Newline Statements [Section: name, _, _, statements]
            |  'loop' ':' Newline Statements [Section: name, _, _, statements]
            |  'bailout' ':' Newline Exp Newline  [Section: name, _, _, statements]
            |  'default' ':' Newline Defstatements [Section: name, _, _, statements]
#            # global, transform, builtin, switch, final

    Defstatements -> Defstatement+    [Defstatements: defstatements]
    Defstatement -> Setting [^]
               | "param" Identifier Newline 
                    Settings
               | "endparam" Newline [Param: _,id,_,settings,_,_]

    Settings -> Setting+ [Settings: settings]
    Setting -> Identifier '=' Value Newline [Setting: id,_,value,_]

    Value -> String [^]
          |  Exp [^]

    Statements -> Statement+          [Statements: statements]
    Statement -> Exp Newline #AssignExp            [^] 
#               | Type AssignExp       [TypedAssignment: type, exp]

#    AssignExp -> Identifier '=' Exp Newline [Assignment: id,_,exp,_]
#              #|  Type Identifier Newline [Declaration: type, id, _]
 
 
#                                      [Condition: left, op, right]

#   Number -> #Integer [^]
#            Float   [^]
# #         | Integer 'i' [Complex: left,_] # FIXME

   Exp -> Float                      [Constant: num]
            |  Identifier                       [Variable: var]
            |  Identifier '=' Exp              [Assignment: var, _, exp]
            |  Type Identifier '=' Exp         [TypedAssignment: type,var,_,exp]
            |  Identifier '(' Exp ')'          [FunCall: function, _, param, _]
            |  '(' Exp ')'             [^: _,exp,_]
            |  '|' Exp '|'             [Magnitude: _, exp, _]
            |  '-' Exp                 [UnaryMinus: _,exp]
            |  Exp '^' Exp            [Exponentiation: left,_,right]
            |  Exp '/' Exp            [Div: left,_,right]
            |  Exp '*' Exp            [Mul: left,_,right]
            |  Exp '+' Exp            [Plus: left,_,right]
            |  Exp '-' Exp            [Minus: left,_,right]
            |  Exp ('<' | '>' | '==' | '<=' | '>=' | '!=' ) Exp [Cond: left,op,right]    
   Priorities
       right(Exponentiation), left(Mul), left(Plus), left(Minus), left(Cond)
       FunCall > Assignment = TypedAssignment > UnaryMinus > Exponentiation > Div = Mul > Plus = Minus > Cond
       #Plus = Minus
